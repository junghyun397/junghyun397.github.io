[{"content":"요즘 Github Actions 가 그렇게 맛집이라고 하더군요! 그래서 해 봤습니다: Github Actions 로 Flutter 앱 빌드하기. 이 글에서는 Github Actions에서 Flutter 앱을 Android APK 또는 AppBundle 로 빌드하는 방법을 소개하며, (작동하는지는 불확실하지만,) IOS ipa로 빌드하는 방법도 함께 소개합니다.\nSecret 등록 안드로이드 앱을 스토어에 등록하기 위해서는(=릴리스모드로 빌드하기 위해서는) Android Keystore 가 필요합니다.\nSettings \u0026gt; Secrets \u0026gt; Actions secrets 에서 Secrets 들을 등록해야 합니다.\n ANDROID_KEYSTORE_BASE64 등록: key.jks 를 base64 로 인코딩한 문자열을 등록해야 합니다. base64 key.jks 명령어로 인코딩된 문자열을 등록합니다. ANDROID_KEYSTORE_PASSWORD 등록: key.properties 파일에 등록된 키스토어 비밀번호를 등록합니다. ANDROID_KEY_ALIAS 등록: key.properties 파일에 등록된 키스토어 Alias 를 등록합니다. ANDROID_KEY_PASSWORD 등록: key.properties 파일에 등록된 키 비밀번호를 등록합니다.  Workflow 파일 작성 Secret 들을 등록 했다면, Workflow 파일을 생성해 CI 스크립트를 작성해 작업을 마무리할 수 있습니다. 우선, 저장소에 .github / workflows / flutter.yml 파일을 생성해 workflow 파일을 생성합니다.\nname: Flutter CI on: push: branches: [ master ] pull_request: branches: [ master ] master branch 의 push와 pull request 이벤트에 실행되는 Flutter CI Action 을 정의합니다.\nAndroid 빌드 jobs: build_android: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Flutter uses: subosito/flutter-action@v1.4.0 with: channel: \u0026#39;stable\u0026#39; Flutter를 사용하기 위해, ubuntu-latest 에서 Flutter Actions 을 사용해 환경을 갖춥니다.\n- name: Download Android keystore id: android_keystore uses: timheuer/base64-to-file@v1.0.3 with: fileName: key.jks encodedString: ${{ secrets.ANDROID_KEYSTORE_BASE64 }} - name: Create key.properties run: |echo \u0026#34;storeFile=${{ steps.android_keystore.outputs.filePath }}\u0026#34; \u0026gt; android/key.properties echo \u0026#34;storePassword=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}\u0026#34; \u0026gt;\u0026gt; android/key.properties echo \u0026#34;keyPassword=${{ secrets.ANDROID_KEY_PASSWORD }}\u0026#34; \u0026gt;\u0026gt; android/key.properties echo \u0026#34;keyAlias=${{ secrets.ANDROID_KEY_ALIAS }}\u0026#34; \u0026gt;\u0026gt; android/key.properties 안드로이드 앱 빌드를 위해, 앞서 업로드 했던 Android Keystore를 다운로드하고 배치합니다. key.jks 파일을 배치하고, 앞서 업로드한 ANDROID_KEYSTORE_PASSWORD , ANDROID_KEY_PASSWORD , ANDROID_KEY_ALIAS 를 key.properties 파일에 작성합니다. 이 부분의 출처는 Albert221의 flutter-release.yml 스크립트입니다.\n- name: Install dependencies run: flutter pub get - name: Build APK run: flutter build apk --release 의존 패키지들을 설치하고, 릴리즈 모드로 apk 파일을 빌드합니다. apk 대신 appbundle 을 사용하면 appbundle 을 빌드할 수 있습니다.\n- name: Rename APK run: mv build/app/outputs/flutter-apk/app-release.apk ./ExampleApp-SNAPSHOT.apk - name: Archive APK uses: actions/upload-artifact@v1 with: name: android-build path: ./ExampleApp-SNAPSHOT.apk 빌드된 apk 파일의 이름을 바꾸고, artifact 로 업로드 합니다. 이 부분을 플레이 스토어에 publish 하는 기능으로 바꿔 Continuous Delivery를 구현할 수도 있습니다!\nIOS 빌드 IOS 빌드를 원한다면, 이 코드를 추가로 삽입하면 됩니다. 이 코드는 ipa 추출 전 단계의 폴더를 압축해 artifact에 업로드하는 코드입니다. 하지만 안타깝게도 전 Apple Developer Program 이 없기에, ipa 빌드는 실험 해볼 수 없었습니다. 언제가 될지는 모르겠지만, 99 USD / Year 의 Apple Developer Program 을 얻게 된다면 글을 업데이트 하도록 하겠습니다!\nbuild_ios: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Set up Flutter uses: subosito/flutter-action@v1.4.0 with: channel: \u0026#39;stable\u0026#39; - name: Install dependencies run: flutter pub get - name: Build IOS run: flutter build ios --release --no-codesign # - name: Export IPA # run: | # cd ios # xcodebuild -workspace Runner.xcworkspace -scheme Runner -sdk iphoneos -configuration Release archive -archivePath $PWD/build/Runner.xcarchive # xcodebuild -exportArchive -archivePath $PWD/build/Runner.xcarchive -exportOptionsPlist ExportOptions.plist -exportPath $PWD/build/Runner.ipa # - name: Rename IPA # run: mv ios/build/Runner.ipa/Runner.ipa ./ExampleApp-SNAPSHOT.ipa # - name: Archive IPA # uses: actions/upload-artifact@v1 # with: # name: ios-build # path: ./ExampleApp-SNAPSHOT.ipa - name: Archive IOS uses: actions/upload-artifact@v1 with: name: ios-build path: build/ios/iphoneos Flutter.yml 완성된 Flutter.yml 은 다음과 같습니다:\nname: Flutter CI on: push: branches: [ master ] pull_request: branches: [ master ] jobs: build_android: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Flutter uses: subosito/flutter-action@v1.4.0 with: channel: \u0026#39;stable\u0026#39; - name: Download Android keystore id: android_keystore uses: timheuer/base64-to-file@v1.0.3 with: fileName: key.jks encodedString: ${{ secrets.ANDROID_KEYSTORE_BASE64 }} - name: Create key.properties run: |echo \u0026#34;storeFile=${{ steps.android_keystore.outputs.filePath }}\u0026#34; \u0026gt; android/key.properties echo \u0026#34;storePassword=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}\u0026#34; \u0026gt;\u0026gt; android/key.properties echo \u0026#34;keyPassword=${{ secrets.ANDROID_KEY_PASSWORD }}\u0026#34; \u0026gt;\u0026gt; android/key.properties echo \u0026#34;keyAlias=${{ secrets.ANDROID_KEY_ALIAS }}\u0026#34; \u0026gt;\u0026gt; android/key.properties - name: Install dependencies run: flutter pub get - name: Build APK run: flutter build apk --release - name: Rename APK run: mv build/app/outputs/flutter-apk/app-release.apk ./ExampleApp-SNAPSHOT.apk - name: Archive APK uses: actions/upload-artifact@v1 with: name: android-build path: ./ExampleApp-SNAPSHOT.apk build_ios: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Set up Flutter uses: subosito/flutter-action@v1.4.0 with: channel: \u0026#39;stable\u0026#39; - name: Install dependencies run: flutter pub get - name: Build IOS run: flutter build ios --release --no-codesign # - name: Export IPA # run: | # cd ios # xcodebuild -workspace Runner.xcworkspace -scheme Runner -sdk iphoneos -configuration Release archive -archivePath $PWD/build/Runner.xcarchive # xcodebuild -exportArchive -archivePath $PWD/build/Runner.xcarchive -exportOptionsPlist ExportOptions.plist -exportPath $PWD/build/Runner.ipa # - name: Rename IPA # run: mv ios/build/Runner.ipa/Runner.ipa ./ExampleApp-SNAPSHOT.ipa # - name: Archive IPA # uses: actions/upload-artifact@v1 # with: # name: ios-build # path: ./ExampleApp-SNAPSHOT.ipa - name: Archive IOS uses: actions/upload-artifact@v1 with: name: ios-build path: build/ios/iphoneos 이게 끝입니다! 이제 무료로 (빌드) 해주는 Github Actions을 즐겨 봅시다. :)\n","permalink":"https://do1ph.in/posts/flutter-action/","summary":"요즘 Github Actions 가 그렇게 맛집이라고 하더군요! 그래서 해 봤습니다: Github Actions 로 Flutter 앱 빌드하기. 이 글에서는 Github Actions에서 Flutter 앱을 Android APK 또는 AppBundle 로 빌드하는 방법을 소개하며, (작동하는지는 불확실하지만,) IOS ipa로 빌드하는 방법도 함께 소개합니다.\nSecret 등록 안드로이드 앱을 스토어에 등록하기 위해서는(=릴리스모드로 빌드하기 위해서는) Android Keystore 가 필요합니다.\nSettings \u0026gt; Secrets \u0026gt; Actions secrets 에서 Secrets 들을 등록해야 합니다.\n ANDROID_KEYSTORE_BASE64 등록: key.jks 를 base64 로 인코딩한 문자열을 등록해야 합니다.","title":"Github Actions로 Flutter 앱 빌드하기"},{"content":"우선 전 Corsair 사의 일체형 쿨러인 H100i v2를 4년간 사용하고 있었습니다. 우분투 18.04를 사용할 때는 윈도우에서 작동하는 CorsairLink에서 설정한 값이 잘 유지가 되었었지만, 어째 20.04로 넘어오니 부팅할 때 마다 수냉쿨러 설정값이 초기화 되더군요. 극저소음 빌드를 지향했기에 펌프와 팬 두 개가 웅웅대는 소음이 여간 거슬리는 게 아니었습니다. 물론 이를 해결할 수 있는 CorsairLink는 당연하게도(\u0026hellip;) 리눅스를 지원하지 않았습니다.\nCorsairLink에서 수냉쿨러에 USB로 어떤 패킷을 보내는지 덤프라도 떠 봐야 하나 싶었지만, 이미 liquidctl이라는 훌륭한 해결책이 존재했습니다. 직접 확인 해본건 아니지만, NEXT Kraken 제품군에도 먹힌다는걸 보면 Asetek OEM 펌프는 대부분 호환되지 않을까 싶습니다.\nliquidctl 설치  당연하지만 liquidctl를 사용하기 위해서는 수냉쿨러가 메인보드와 USB로 연결되어 있어야 합니다.  liquidctl 은 pip를 이용해 배포됩니다. pip3 를 이용해 liquidctl 을 설치합니다.\nsudo pip3 install liquidctl 이제 liquidctl 명령어를 이용해서 수냉쿨러를 컨트롤 할 수 있습니다! 우선, 아래 명령어를 이용해 liquidctl이 지원하는 수냉쿨러를 사용하고 있는지 확인합니다.\nliquidctl list Device ID 0: Corsair H100i Pro XT (experimental) 과 같은 장치가 보인다면 liquidctl 을 사용할 수 있는 상태입니다. liquidctl README.md 에서 사용하고 있는 장치에서 사용할 수 있는 명령어를 확인 할 수 있습니다.\n명령어  기기마다 사용 가능한 명령어들이 모두 다릅니다! liquidctl README.md 에서 자신이 사용하고 있는 기기 페이지에 들어가 사용 가능한 명령어 조합을 확인해 주세요. 아래 명령어들은 제가 사용 중인 Corsair H100i Pro XT 에서 작동하는 몇 가지 명령어들에 대한 소개입니다.  liquidctl initialize --pump-mode \u0026lt;mode\u0026gt; : 수냉쿨러를 초기화 하면서 펌프 모드를 설정할 수 있는 명령어입니다. quiet, balanced, extreme 로 펌프 모드를 설정할 수 있습니다. ex) liquidctl initialize --pump-mode quiet 명령어로 수냉쿨러를 조용한 모드로 초기화 할 수 있습니다.\nliquidctl set \u0026lt;fan\u0026gt; speed \u0026lt;temperature\u0026gt; \u0026lt;duty\u0026gt; \u0026lt;temperature1\u0026gt; \u0026lt;duty1\u0026gt; ... : 수냉쿨러에 연결된 팬 속도를 온도에 따라 조정할 수 있는 명령어입니다. 온도는 수냉쿨러 냉각수 온도를, 속도는 백분율 단위로 작성되어야 합니다. ex) liquidctl set fan speed 40 10 65 40 명령어로 수온이 40도일 때 팬을 10% 로, 수온이 65도일 때 팬을 40% 속도로 돌리도록 설정할 수 있습니다.\nliquidctl set led color \u0026lt;mode\u0026gt; \u0026lt;colors\u0026gt; : 수냉쿨러의 자켓에 달린 LED 색을 설정할 수 있는 명령어입니다. ex) liquidctl set led color super-fixed 2000ff 2000ff 2000ff 2000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff --unsafe=pro_xt_lighting 명령어로 자켓에 달린 개별 LED 를 각각 HTML 색상 코드로 항상 켜져있도록 설정할 수 있습니다.\n이외에도 더 많은 명령어들이 있습니다!\n서비스 등록 시스템 부팅과 함께 liquidctl 이 시작될 수 있도록, liquidctl 을 서비스로 등록해야 합니다. liquidcfg.service 파일을 만들어 서비스를 생성합니다.\nsudo vi /etc/systemd/system/liquidcfg.service liquidcfg.service 에 아래 스크립트를 붙여놓고 저장합니다. 아래 스크립트는 Corsair H100i Pro XT 를 기준으로 작성된 스크립트로, 펌프를 quiet 모드로, 팬 속도를 사용자 지정 곡선으로, LED를 파란색과 보라색으로 설정하는 코드를 시스템 부팅시 10초 뒤 실행하는 코드입니다.\n[Unit] Description=AIO initialize service [Service] Type=oneshot ExecStart=sleep 10 ExecStart=liquidctl initialize --pump-mode quiet ExecStart=liquidctl set fan speed 40 10 50 20 60 30 65 40 ExecStart=liquidctl set fan1 speed 40 10 50 20 60 30 65 40 ExecStart=liquidctl set led color super-fixed 2000ff 2000ff 2000ff 2000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff 0000ff --unsafe=pro_xt_lighting [Install] WantedBy=default.target 이제 등록된 liquidcfg.service 서비스를 아래 명령어로 활성화 할 수 있습니다.\nsudo systemctl enable liquidcfg sudo systemctl start liquidcfg 좋습니다! 이제 부팅과 함께 liquidcfg 서비스가 실행될 것 입니다. 하지만 여기 한 가지 문제가 남았습니다: 시스템이 sleep mode 에 들어갔다 다시 부팅됐을 때, 수냉쿨러를 다시 초기화 할 방법이 없습니다. 이를 위해서는 시스템이 sleep mode 에서 부팅될 때 수냉쿨러를 초기화 할 스크립트를 추가로 작성할 필요가 있습니다.\nSleep-mode 스크립트 등록 liquidcfg.sh 파일을 만들어 스크립트를 생성합니다.\nsudo vi /lib/systemd/system-sleep/liquidcfg.sh liquidcfg.sh 에 앞서 등록한 서비스를 실행시키는 아래 스크립트를 붙여넣고 저장합니다.\n#!/bin/bash sudo systemctl start liquidcfg 작성된 스크립트가 실행될 수 있도록 권한을 설정하면 끝입니다!\nsudo chmod a+x /lib/systemd/system-sleep/liquidcfg.sh OpenCorsairLink  만약 liquidctl 이 먹히지 않는다면, 아래 OpenCorsairLink 앱을 이용하는 방법을 참조 해주세요. liquidctl 이 나오기 전까지 사용하던 방법이자, 무려 이 글의 본문이었던 글 입니다.  설치를 위해 우선 OpenCorsairLink 저장소를 클론한 뒤 빌드합니다.\ngit clone https://github.com/audiohacked/OpenCorsairLink.git cd OpenCorsairLink make 빌드를 마쳤다면 OpenCorsairLink가 OpenCorsairLink.elf 로 출력된걸 확인할 수 있습니다.\nsudo ./OpenCorsairLink.elf --version Dev=0, CorsairLink Device Found: H100i Pro! 와 같이 프로그램의 버전과 USB로 연결된 수냉쿨러의 디바이스 번호를 알아낼 수 있습니다. 여기서 Dev=0만 기억하면 됩니다. 이제 OpenCorsairLink 바이너리를 이용해 수냉쿨러를 컨트롤 할 수 있습니다!\n./OpenCorsairLink.elf --help # 번역할 필요가 있을까 싶지만 반만 번역해 봤습니다. Options: --help\t:이 메시지를 프린트 합니다. --version\t:버전을 표시 합니다. --debug\t:디버그 메시지를 표시 합니다. --dump\t:--debug를 의미합니다. 디바이스에서 받은 raw데이터를 덤프합니다. --machine\t:쿨러의 상태를 읽을 수 있는 포맷으로 표시해 줍니다. --device \u0026lt;Device Number\u0026gt;\t:장치를 선택합니다. LED: --led channel=N,mode=N,colors=HHHHHH:HHHHHH:HHHHHH,temps=TEMP:TEMP:TEMP Channel: \u0026lt;led number\u0026gt; :설정할 LED채널을 선택합니다. 1 또는 2를 적으세요. Mode: 0 - 정적 1 - 깜빡임 (커맨더 프로 또는 아세텍 프로와 호혼) 2 - 색 박동 (커맨더 프로 또는 아세텍 프로와 호혼) 3 - 색 변화 (커맨더 프로 또는 아세텍 프로와 호혼) 4 - 무지개 (커맨더 프로 또는 아세텍 프로와 호혼) 5 - 온도 (커맨더 프로 또는 아세텍, 아세텍 프로와 호혼) Colors: \u0026lt;HTML Color Code\u0026gt;\t:Define Color for LED. Warn: \u0026lt;HTML Color Code\u0026gt;\t:Define Color for Warning Temp. Temps: \u0026lt;Temperature in Celsius\u0026gt;\t:Define Warning Temperatures. Fan: --fan channel=N,mode=N,pwm=PWM,rpm=RPM,temps=TEMP:TEMP:TEMP,speeds=SPEED:SPEED:SPEED Channel: \u0026lt;fan number\u0026gt; :Selects a fan to setup. Accepted values are 1, 2, 3 or 4. Modes: 0 - 고정 PWM (PWM 지정 필요) 1 - 고정 RPM (RPM 지정 필요) 2 - 기본 3 - 정죽 4 - 균형 5 - 퍼포먼스 6 - 커스텀 커브 PWM \u0026lt;PWM Percent\u0026gt; :The desired PWM for the selected fan. NOTE: it only works when fan mode is set to Fixed PWM RPM \u0026lt;fan RPM\u0026gt; :The desired RPM for the selected fan. NOTE: it works only when fan mode is set to Fixed RPM For Custom Curves: Temps \u0026lt;C\u0026gt;\t:Define Celsius Temperatures for Fan. Speeds \u0026lt;Percentage\u0026gt;\t:Define Values of RPM Percentage for Fan. Pump: --pump mode=\u0026lt;mode\u0026gt; Modes: 3 - 정숙 4 - 균형 5 - 퍼포먼스 아래는 디바이스 0에 해당하는 수냉쿨러에 대해, LED 채널 1에 대해 정적 모드로 #1500ff 를 표시하며, 쿨링팬 채널 1에 대해 정숙모드를 설정하고 펌프를 균형 모드로 설정하는 명령어 입니다.\nsudo ./OpenCorsairLink.elf --device 0 --led channel=1,mode=0,colors=1500ff --fan channel=1,mode=3 --pump mode=4 적당히 쉘 스크립트로 만들어서 crontab 에 등록 하거나 해서 활용 하면 되겠습니다. Corsair H100i v2와 Corsair H100i PRO RGB에서 정상 작동을 확인 했습니다.\n@reboot YOUR-PATH/ConfigureAIO.sh  crontab에 @reboot로 등록한 task는 suspend와 같은 stand-by-mode상태 이후에 자동으로 실행되지 않습니다. .bashrc나 .zshrc에 PATH를 등록해서 수동으로 스크립트를 실행해 줘야 합니다.  export PATH=\u0026#34;$PATH:YOUR-PATH\u0026#34; ","permalink":"https://do1ph.in/posts/control-aio-in-linux/","summary":"우선 전 Corsair 사의 일체형 쿨러인 H100i v2를 4년간 사용하고 있었습니다. 우분투 18.04를 사용할 때는 윈도우에서 작동하는 CorsairLink에서 설정한 값이 잘 유지가 되었었지만, 어째 20.04로 넘어오니 부팅할 때 마다 수냉쿨러 설정값이 초기화 되더군요. 극저소음 빌드를 지향했기에 펌프와 팬 두 개가 웅웅대는 소음이 여간 거슬리는 게 아니었습니다. 물론 이를 해결할 수 있는 CorsairLink는 당연하게도(\u0026hellip;) 리눅스를 지원하지 않았습니다.\nCorsairLink에서 수냉쿨러에 USB로 어떤 패킷을 보내는지 덤프라도 떠 봐야 하나 싶었지만, 이미 liquidctl이라는 훌륭한 해결책이 존재했습니다.","title":"리눅스에서 liquidctl로 수냉쿨러 컨트롤 하기"},{"content":"2019년 7월부터 2020년 3월까지, 약 9개월간 진행된 Best of the Best 8기 보안제품 개발 트랙을 수료 했습니다. 고등학교와 BoB활동을 동시에 진행 한만큼 힘든점도 많았고 양쪽 모두에 성실히 참여 했다고도 단정할 수 없지만, 힘들었던 만큼 얻어간 결과도 확실 하기에 정말로 추천 드릴만한 교육 과정이라 할 수 있습니다.\n누구나 한 번은 찍어 본다는 안양천 뷰\n지난 9개월동안의 BoB활동을 정리하며 BoB가 도대체 뭐 하는 곳인지 궁금한 분이나 BoB에 지원할 계획이 있는 분에게 도음이 될겸 BoB 지원과 BoB생활, 그리고 개인적인 리뷰를 적어 보겠습니다. 원래는 수료장을 받은 3월 말에 작성하려고 했지만, 이핑계 저핑계 대며 미루다 보니 9기 모집 목전에야 초본을 작성하게 됐네요.\n지원, 합격 BoB의 지원 과정은 총 4단계로 진행 됩니다. 우선 자기소개서와 포트폴리오를 받는 서류 심사, 서류 심사를 통과한 사람들을 대상으로 웹으로 진행되는 인적성 검사, 그리고 심층 면접과 함께 진행되는 필기 시험순서대로 진행 됩니다. 마감일에 맞춰서 접수 했다면 약 6주 뒤에 최종 합격 여부를 알 수 있습니다.\n서류 심사 서류 심사, 보통 1차라고 부르는 온라인 지원 서류의 경우 자기소개와 포트폴리오, 경력사항과 지망 트랙을 적어서 LMS에 제출하면 됩니다. 얼마나 많은 내용을 적을 것이냐에 따라 갈리겠지만, 보통 3~4시간, 많게는 한달 내내 서류를 준비 했다는 합격자도 많이 보였습니다. 제 경우 핵심적인 경력(?)만 요약해 적었기에 서류 전형을 준비하는데 약 3시간 정도 걸렸던 것 같습니다.\n자기 소개는 Best of the Best에 지원한 포부를 잘 살려서 작성 하시면 됩니다. 이번 9기의 경우 확인 결과 자기 소개, 본인이 이룬 성과, 지원 동기, 합격 후 포부, 학습 계획서, 진로 계획을 각각 1000자 이내로 작성하게 되어 있습니다. 전 일반적인 자기소개와 포트폴리오/경력사항과 엮이도록 성과나 학습 계획들을 적었습니다. 당연하지만 길게 작성 한다고 무조건 유리한것이 아니니, 본인의 포부를 가장 잘 나타내도록 두괄식으로 간략히 적으라 는 뻔한 솔루션이 존재 하겠습니다.\n포트폴리오/경력사항은 자격증, 어학, 수상경력, 교육사항, 보유기술, 기술발표, 발표논문, 취약점 제보이력, 프로젝트 기술서, 추천서/포트폴리오를 선택사항으로 추가할 수 있습니다. 제 경우에는 수상경력에 소규모 PS대회 경력 하나와 프로젝트 기술서에 여태까지 진행해 왔던 프로젝트를 Github저장소와 함께 첨부했으며 보유기술에 사용 가능한 기술 목록 - 간단히는 프로그래밍 언어, 프레임워크, 시스템, 암호학, 웹해킹 등 - 을 나열 했습니다.\n추천서는 보통 지도 교수나 담임 선생님, 교장과 같은 교직원에게 받아서 제출하는 것 같았습니다. 우선 전 추천서를 제출하지 않아서 이 부분에 대해서는 잘 모르겠습니다. 많은 케이스를 조사 한건 아니지만, 다수의 합격자들은 추천서를 제출 했던 것 갔았습니다.\n지망 트랙의 경우, 1순위부터 4순위까지를 정해서 지원해야 하는데 최종적으로 BoB에서 수료하게 될 트랙과는 큰 관련이 없으니 부담없이 가장 자신있는 분야를 1순위로 배치 하기시를 권장 드립니다. 면접은 1순위 지망 트랙을 담당하는 멘토 분들과 진행하게 되지만, 공통교육 과정 이후 다시 시험을 쳐서 희망 트랙으로 배정되게 됩니다. 예를 들어 디지털 포렌식 트랙에 지원하고 싶은데, 자신 있는 분야는 취약점 분석이라면 취약점 분석을 1지망으로 지원한 뒤, 공통교육 과정이 끝났을 때 디지털 포렌식트랙을 지원하면 됩니다. 제 경우는 보안제품 개발을 1지망으로 적었습니다.\n자기소개도 꽉꽉 채우고 있는 기록 없는 기록 다 짜내서 포트폴리오도 빵빵하게 채운데다 추천서에 여러 입상 기록까지 첨부 해야 합격 한다는 말이 있지만, 제 경우에는 자기소개를 다 채우지도 않았고, 수상 경력도 많지 않았거니와 추천서도 첨부하지 않았는데 서류 심사를 무난히 합격할 수 있었습니다. 사실 무난히 인지는 잘 모르겠지만 말이에요.\n인적성 검사 인적성 검사는 서류 심사 합격자를 대상으로 이메일로 공지 후 웹으로 진행합니다. 인적성 검사라는 단어만 보고 막연히 애매한 문제가 나올까 싶어 걱정도 했었지만\u0026hellip; 아주 간단한 지능 테스트와 인터넷에서도 흔히 체험할 수 있는 성격 유형 검사 정도의 수준으로 구성됩니다. 보안과 관련된 내용은 포함되지 않으니 걱정 하지 않아도(?) 되겠습니다.\n필기 시험 필기 시험은 공식 공지에도 나와 있듯이 보안기사나 산업기사수준 정도로 나온다고 합니다고 하지\u0026hellip;만, 산업기사나 보안기사 시험을 본적이 없기에 정말로 비슷한지는 잘 모르겠습니다. 자세한 내용을 그대로 적을수는 없지만, BoB를 지원할 정도의 어느정도 기초적인 보안 지식을 가지고 계신다면, 무난하게 풀 수 있을 정도의 수준으로 출제 됩니다.\n떠도는 소문에 의하면 필기시험이 합격 여부에 영향을 주지 않는다고도 하는데, 이게 사실인지는 저도 잘 모르겠습니다. 확실하지 않은만큼 시험치기 전날 최소한의 공부 만큼은 하고 시험을 치는게 좋지 않을까 싶습니다. 공부 해봤자 손해 볼건 없으니까 말이에요.\n심층 면접 빡세다고 소문난 대망의 심층 면접입니다. 서류 심사를 2배수로 선발하니 당연하겠지만, 심층 면접에서 절반이 걸러지게 됩니다. 심층 면접은 8기의 경우, BoB에서 하고싶은 프로젝트를 PT 형식으로 발표 하고 질의응답을 받는 형식으로 진행 했습니다.\n1차 교육기간 우선 합격 하셨으면 축하드립니다. 이제 내년 1월까지는 정신없이 바쁜 일정을 소화 하셔야 합니다. 가장 먼저 코앞으로 다가온 일정은 BoB의 악명의 원천, 1차 집체교육이 기다리고 있습니다. 1차 집체교육이 이루어 지는 동안 제대로수업을 따라 가기만이라도 했다면 적어도 **기초적인 ** 보안 이론과 실무 지식은 어느정도 적당히 넓게 알아갈 수 있을 정도로 넓은 범위의 기초지식을 확실하게, 실무에 가깝게 배우게 됩니다.\n무려 광복절 새벽 6시입니다.\n10to10, 오전 10시에 시작해서 오후 10시에 끝나는 기적의 일정을 휴일 없이 2달동안 소화해야 하는 기적의 1차교육 일정입니다. 심할때는 8시에 시작해서 23시에 끝난적도 있었습니다. 정확히 뭘 배우는지에 대해 자세한 일정을 공유해 드릴수는 없지만, 우선 공통교육과 트랙별 수업을 들어야 한다는 것부터 시작 해야겠네요.\n공통 교육 1차교육이 시작 되면 우선 2주동안 공통 교육을 받게 됩니다. 공통교육 기간 동안에는 트랙 구분 없이 공통으로, 모두 같은 내용으로 보안의 기초 지식을 다지게 됩니다.\n트랙별 심화 교육 교육생 지원 현물 지원의 경우 i7 프로세서가 달린 하얀색 그램 14인치 모델과 월 30만원정도의 교육 지원금을 받게 됩니다. 지방에서 올라온 사람들을 위한 숙소로는 숭실대학교 기숙사가 제공 된다고 합니다. 제공되는 노트북은 판매 금지 각서(?)를 작성 후 수령하게 되며, 써본 사람들에 의하면 성능은 나쁘지 않은 수준이라고 합니다. 30만원이라도 주는 지원금에 감사 하는게 맞겠지만, 30만원으로 밥+간식+각성제를 해결 하기에는 정말 빠듯합니다.\n만약 인문계 고등학교를 다닌다면 만약 일반 인문계 고등학교에 재학중 이라면, 상황에 따라 다르겠지만 학교는 매우 비협조적인 자세를 보일 가능성이 있습니다. 전 당시 일반 인문계 고등학교 과학중점반 3학년에 재학중 이었습니다. 특성화고가 아닌 일반 인문계 고등학교 출신인지라 출석 인정 관련 정보를 찾기 쉽지 않았지만 BoB위키를 찾아봐도, 7기 선배에게 물어봐도 BoB에서 발급 해주는 공문을 제출 한다면 학교장 재량으로 출석 인정 처리를 해 준다고 했습니다.\n출석 인정 처리를 해 준다는 말만 믿고 별 생각 없이 공문을 담임선생에게 가져 갔지\u0026hellip;만, 공문을 읽어보지도 않고 \u0026ldquo;안 된다\u0026quot;를 시전해 한창 실랑이를 벌였습니다. 결국 끝까지 막무가내로 \u0026ldquo;안 된다\u0026quot;라는 말을 앵무새마냥 반복하다 선례를 가져와라\u0026quot;를 시전하며 일처리를 미루기에 마침 학교에 계시던 선*인터넷 고등학교 출신 영어 선생님에게 가서 \u0026ldquo;선례\u0026quot;를 수집해 갔지만 결국 돌아 오는건 \u0026ldquo;우리학교가 선린인고냐\u0026quot;는 대답 뿐이더군요. 교장 선생님에게 직접 찾아가서 상황을 설명 해봤지만 출석 인정 자체가 담임 결제가 필요 하다는 대답이 돌아 왔었습니다. 답이 없어요.\n결국 출석 인정 처리를 받지 못 했고 이후 담임에게 들은 말은 \u0026ldquo;미인정 결석을 하던지 학교에 나오던지 그건 니 선택이다\u0026rdquo; 뿐 이었습니다. 별 수 있나요. 꾸역꾸역 별 도움도 안 되는 자습시간으로 꽉 찬 학교에 다닐 수밖에 없죠. 인문계 고등학교를 다니며 BoB를 지원할 생각이라면, 일찍부터 담임과의 관계를 신경써서 관리 하는 것을 추천 드립니다. 여러모로 더럽다고 할 수 있겠지만, 어쩔 수 없습니다. 아직 꼰대들이 널려있는 한국 사회니까요.\n팀 프로젝트 기간 1차교육 막바지에 구성한 팀으로 약 3달간 유의미한 결과를 내야 하는 팀 프로젝트입니다. 1차 교육이 끝날 무렵 임명장이 나오는 만큼 BoB센터에서는 팀 프로젝트를 BoB의 시작이라 보는것 같습니다.\n2차 교육기간 만약 팀 프로젝트 기간동안 유의미한 결과를 냈다면, TOP30, 그리고 TOP10에 선정돼 2차 교육기간동안 \u0026ldquo;프로젝트 고도화\u0026quot;를 진행하게 됩니다. TOP30에도 들지 못한게 내심 아쉽긴 하지만\u0026hellip; 제 일정상 그럴 여력도 없었고 그만큼 열심히 하지도 않았기에 어느정도 당연한 결과라고 생각합니다. TOP30안에 들어가신 분 모두 1차교육과 팀 프로젝트 기간 모두 센터의 지박령급으로 정말로 열심히 교육을 수료 하셨기에 그만한 성과를 낸 것이 분명합니다. 물론 TOP30에 들지 않는다고 해도 교육이 끝난 것은 아닙니다. 2차 교육이 기다리고 있으니까요.\n지난 기수에는 TOP30안에 들지 못 하면 그대로 교육이 끝났다고 들었는데, 8기부터는 TOP30안에 들지 못 하였더라도 2차 교육을 받아야 합니다. 교육 내용은 1차 교육기간이 어느정도 기초적이고 이론적인 내용을 다뤘다면, 2차 교육기간은 어느정도 실무에 가까운 내용을 다룹니다. 교육 형식은 1차 교육과 비슷하게 센터에 모여서 수업을 듣고, 출퇴근 시간 체크를 하는 방식으로 진행되지\u0026hellip;만, 사실 필수는 아니라서 1차교육의 1/3도 모이지 않는 기적을 체험할 수 있습니다.\n수료 2달간의 1차 교육, 3달간의 팀 프로젝트, 2달간의 2차 교육을 성공적으로 마친 뒤 수료 시험을 통과 한다면, 드디어 Best of the Best 수료생이 된 것 입니다!\n종이 조각과 황동 덩어리, 뭘 이런걸 다\u0026hellip;\n후기 서두에도 적었듯이 워낙 뜬금없이 합격 한데다, 고등학교 생활과 병행하는데 학교조차 매우 비협조적인 태도를 보여줘서 결국 두 마리의 토끼를 잡는데에는 실패한 것 같습니다. 그래도 1차 교육과 2차 교육을 날밤을 새가며 받으며 정말 많은 지식과 경험을 쌓을 수 있었고, 팀 프로젝트를 통해 긍정적인 면이던 부정적인 면이던, 처음으로 협업을 경험해 보게 되었습니다. 특히 제 원래 목적이었던 부족한 Low End는 BoB를 통해 확실히 다져놓을 수 있었습니다. 전반적인 시스템과 네트워크에 대한 심도있는 지식은 덤이고요.\nBoB자체가 그저 수업만 듣고 과제도 \u0026ldquo;최소한의 인정 한도\u0026quot;내에서 제출 한다면 그닥 빡세지는 않은 평범한 과정이라는 생각이 드실수도 있을것 입니다. 저도 어느정도 날먹해버린 과제가 있기에 생각보다 할만 한데? 라는 생각이 들기도 했었습니다. 과제를 대충 제출 한만큼, 수업을 건성으로 들은만큼 가져가는 지식의 양은 줄어듭니다. 어디까지나 BoB 과정이라는 환경이 주어지는 동안 본인이 얼마나 노력 했는지에 따라 가져가는 결과 역시 달라 지는 것 같습니다. 어찌보면 당연하지만 항상 열심히 한다 는게 생각보다 쉽지는 않았습니다.\n아쉬운 면도 적지 않은데다 시기적으로도 적절하지 않았지만, 그래도 9개월간 BoB활동을 하며 얻어간 경험들은 다른 경함과는 비교할 수 없는 종류의 경험 이었습니다. 다시 지원 직전으로 돌아간다면 다시 지원할 것 같네요. 멋진 경험 이었습니다.\n 어딘가 반쯤 쓰다 만거 같은 글인것 같은 느낌이 드셨다면, 애석하게도 그것은 사실일 가능성이 높습니다. 더 풀어 보고 싶은 이야기는 많지만 귀차니즘이 더 이상 작성 하는 것을 허락하지를 않네요. 최소한 5월 중순까지는 계속 수정할 예정이니 더 자세한 정보를 얻고 싶다면 5월 말엽에 다시 이 글을 찾아 오시면 되겠습니다.\n Best of the Best 9기 모집이 시작되었습니다. BoB 지원 및 활동에 관련된 궁금한 사항이 더 있으시다면 부담없이 댓글 남겨 주시면 답변 드리겠습니다. 9기에 지원 하시는분 모두 노력한 만큼 좋은 결과 얻으시기를 바랍니다! :)\n","permalink":"https://do1ph.in/posts/8th-best-of-the-best/","summary":"2019년 7월부터 2020년 3월까지, 약 9개월간 진행된 Best of the Best 8기 보안제품 개발 트랙을 수료 했습니다. 고등학교와 BoB활동을 동시에 진행 한만큼 힘든점도 많았고 양쪽 모두에 성실히 참여 했다고도 단정할 수 없지만, 힘들었던 만큼 얻어간 결과도 확실 하기에 정말로 추천 드릴만한 교육 과정이라 할 수 있습니다.\n누구나 한 번은 찍어 본다는 안양천 뷰\n지난 9개월동안의 BoB활동을 정리하며 BoB가 도대체 뭐 하는 곳인지 궁금한 분이나 BoB에 지원할 계획이 있는 분에게 도음이 될겸 BoB 지원과 BoB생활, 그리고 개인적인 리뷰를 적어 보겠습니다.","title":"Best of the Best 8기 수료 후기"},{"content":"우분투 20.04 장기 지원 버전(LTS) 이 릴리스 되었습니다. 매번 OS를 새로 설치할 때마다 삽질하지 않도록 우분투를 처음 설치했을 때 작업 환경을 세팅하는 과정을 글로 정리해 봤습니다. Pop! shell 및 ifcitx-hangul 설정과 uim-byeoru 설정, oh-my-zsh 설정과 vundle 등의 설정을 포함합니다.\n 개인적으로 사용하기 위해 정리한 성격이 강한 글입니다. 최소한 22.04 LTS가 나오기 전까지는 계속 업데이트 될 예정입니다. Ubuntu 20.04 LTS, 영문 기준으로 작성되었으며, RYZEN 1700 + GTX1080 + NVMe SSD  데스크톱과 DELL XPS 13 9350 랩톱 하드웨어에서 정상 작동을 확인했습니다.  본격적으로 환경을 구성하기 전에, 여러 가지 도구들을 설치해 줘야 합니다. 취향껏 골라 설치하면 되겠습니다.\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade # 빌드 도구 sudo apt install build-essential make cmake clang node-typescript libdbus-1-dev libssl-dev # 패키지 도구 sudo apt install cargo gdebi python3-pip ppa-purge # 관리 도구 sudo apt install openssh-server git curl screen net-tools pm-utils # 모니터링 도구 sudo apt install tldr screenfetch htop tree # X11/GNOME 추가 기능 sudo apt install xdotool x11-xserver-utils gnome-tweak-tool gnome-shell-extensions # 편집기 및 입력기 sudo apt install vim-gtk3 uim uim-byeoru # 한 줄로 모두 설치하기 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade \u0026amp;\u0026amp; sudo apt install build-essential make cmake clang node-typescript libdbus-1-dev libssl-dev cargo gdebi python3-pip ppa-purge openssh-server git curl screen net-tools pm-utils tldr screenfetch htop tree xdotool x11-xserver-utils gnome-tweak-tool gnome-shell-extensions vim-gtk3 uim uim-byeoru -y Swap memory 추가 sudo swapoff /swapfile sudo rm /swapfile sudo dd if=/dev/zero of=/swapfile bs=1M count=32768 sudo chmod 600 /swapfile sudo mkswap /swapfile sudo swapon /swapfile Zsh Shell zsh 를 설치하고 기본 쉘을 zsh 로 변경합니다.\nsudo apt install zsh chsh -s /usr/bin/zsh 로그아웃 이후 로그인하면 기본 쉘이 zsh 로 바뀐 것을 확인할 수 있습니다. 이제 zsh의 사용성을 개선해 줄 oh my zsh 를 설치할 수 있습니다.\nwget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh zsh-syntax-highlighting: Fish shell 과 비슷한 방식으로 zsh 에서 타이핑한 명령어를 자동으로 하이라이팅 해 주는 플러그인입니다. oh-my-zsh 커스텀 폴더에 플러그인 저장소를 clone해줍니다.\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 이후 ~/.zshrc에서 ZSH_THEME=\u0026quot;agnoster\u0026quot; 와 plugins=(git zsh-syntax-highlighting docker docker-compse)을 설정한 뒤, source ~/.zshrc를 입력해 적용합니다.\nsed -i \u0026#34;s/ZSH_THEME=.*/ZSH_THEME=\u0026#39;agnoster\u0026#39;/g\u0026#34; .zshrc sed -i \u0026#34;s/plugins=.*/plugins=(git zsh-syntax-highlighting docker docker-compse)/g\u0026#34; .zshrc source ~/.zshrc GNOME Shell GNOME Shell을 완전히 설정하기 위해, Tweaks 앱에서 다음 설정들을 변경해야 합니다.\n Keyboard \u0026amp; Mouse 에서 다음 설정을 변경해야 합니다.  Control \u0026lt;-\u0026gt; CapsLock 위치 변경: CapsLock 키의 위치는 적폐입니다. 그리 좋은 자리가 Control이 아니라 잘 쓰지도 않는 Caps키라니요. tweaks \u0026gt; Keyboard\u0026amp;Mouse \u0026gt; Keyboard \u0026gt; Additional Layout Options \u0026gt; Ctrl position \u0026gt; Swap Ctrl and Cpas Lock 을 활성화하여 청산합니다. Compose Key 지정: 한글 키 또는 멀티 키가 포함되지 않는 키보드를 사용하고 있다면, 한글-영문 전환 키로 활용할 Compose Key 를 지정해야 합니다. 일반적으로 Alt_R 을 사용합니다.   Workspaces 에서 다음 설정을 변경해야 합니다.  정적 워크스페이스 설정: Static workspaces 를 선택해 정적 워크스페이스를 활성화합니다.    Shell Extension GNOME Shell에 추가 기능을 설치하고 추가 기능을 구성하기 위해, Shell Extension 을 설치하고 Extensions 앱을 이용해 추가 기능을 구성할 수 있습니다.\n기본으로 제공되는 추가기능들을 비활성화/활성화 하기 위해 Extensions 앱에서 추가 기능 활성화를 설정해야 합니다.\n 앱 메뉴를 비활성화하기 위해 Applications Menu 를 disable 로 설정합니다. 바탕화면 아이콘을 비활성화하기 위해 Desktop-icons 을 disable 로 설정합니다. Ubuntu Dock를 비활성화하기 위해 Ubuntu Dock 을 disable 로 설정합니다. 워크스페이스 표시기를 활성화하기 위해 Workspace Indicator 를 enable 로 설정합니다.  이후, 다음 Shell Extension들을 웹 페이지에서 활성화 클릭 또는 컴파일하여 설치합니다.\nPop! Shell 키보드 활용도를 더욱 높여주며, i3wm 과 비슷한 타일링을 가능하게 만들어 주는 Extension인 Pop! Shell입니다. 자세한 설명은 이 링크를 참조해 주세요. Pop! Shell github 저장소를 클론한 뒤 컴파일 및 설치합니다. 설치 시 단축키들이 변경됨으로, 주의해서 설치해주세요.\ncd /tmp git clone https://github.com/pop-os/shell cd shell make local-install GSConnect https://extensions.gnome.org/extension/1319/gsconnect/ 에서 활성화할 수 있습니다.\nKDE의 모바일 기기 연결 서비스인 KDE Connect 의 JavaScript 구현 버전입니다. 배터리 및 알림, 클립보드 동기화와 파일시스템 마운트 기능을 지원합니다.\nUnite https://extensions.gnome.org/extension/1287/unite/ 에서 활성화할 수 있습니다.\n타이틀 바 제거, 앱 메뉴 제거, 윈도우 버튼 위치 변경 등 GNOME 의 여러 요소를 커스터마이징 할 수 있는 확장 앱입니다.\n Activites 영역을 비활성화하기 위해 Hide activities button 을 always 로 설정합니다. 타이틀 바를 숨기기 위해 Hide Window titlebars 을 always 로 설정합니다. 윈도우 타이틀을 앱 메뉴에 표시하기 위해 Show window title in app menu 을 always 로 설정합니다. 윈도우 버튼을 상단 바에 표시하기 위해 Show window buttons in top bar 을 always 로 설정합니다. 상단 바에 표시된 윈도우 버튼의 위치를 설정하기 위해 Top bar window buttons position 을 First 로 설정합니다. 상단 바에 표시된 윈도우 버튼의 테마를 설정하기 위해 Top bar window buttons theme 을 Prof-Gnome 로 설정합니다.  Title bar 제거: GNOME-Terminal 은 Unite 의 Title bar 제거 옵션이 먹히지 않습니다. gsetting 을 이용해 수동으로 타이틀 바를 제거합니다.\ngsettings set org.gnome.Terminal.Legacy.Settings headerbar false Block-Caribou https://extensions.gnome.org/extension/3222/block-caribou-36/ 에서 활성화할 수 있습니다.\n터치스크린 환경에서 가상 키보드 비활성화 기능이 작동하지 않는 버그를 해결 해줍니다. 가상 키보드 관련 문제가 있다면 설치하면 됩니다.\nKeyboard Shortcut Settings \u0026gt; Keyboard Shortcuts 에서 런쳐 및 커스텀 단축키를 등록합니다.\n Launch calcutator \u0026gt; Super + C Chrome incognito \u0026gt; Shift + Super + B, google-chrome --incognito  이후 dconf 를 이용해 i3wm 스타일 워크스페이스 키맵을 등록합니다.\ndconf load '/org/gnome/desktop/wm/keybindings/' \u0026lt; \u0026quot; [/] move-to-workspace-1=['\u0026lt;Shift\u0026gt;\u0026lt;Super\u0026gt;1'] move-to-workspace-2=['\u0026lt;Shift\u0026gt;\u0026lt;Super\u0026gt;2'] move-to-workspace-3=['\u0026lt;Shift\u0026gt;\u0026lt;Super\u0026gt;3'] move-to-workspace-4=['\u0026lt;Shift\u0026gt;\u0026lt;Super\u0026gt;4'] switch-to-workspace-1=['\u0026lt;Super\u0026gt;1'] switch-to-workspace-2=['\u0026lt;Super\u0026gt;2'] switch-to-workspace-3=['\u0026lt;Super\u0026gt;3'] switch-to-workspace-4=['\u0026lt;Super\u0026gt;4'] \u0026quot; Altgr + hjkl 화살표 할당\necho \u0026#34;#!/bin/bash xmodmap -e \u0026#39;keycode 108 = Mode_switch\u0026#39; xmodmap -e \u0026#39;keycode 43 = h H Left H\u0026#39; xmodmap -e \u0026#39;keycode 44 = j J Down J\u0026#39; xmodmap -e \u0026#39;keycode 45 = k K Up K\u0026#39; xmodmap -e \u0026#39;keycode 46 = l L Right L\u0026#39;\u0026#34; \u0026gt; ~/scripts/xmodmap.sh chmod +x ~/scripts/xmodmap.sh echo \u0026#34;[Desktop Entry] Type=Application Exec=$HOME/scripts/xmodmap.sh X-GNOME-Autostart-enabled=true Name=Xmodmap2 Comment=\u0026#34; \u0026gt; ~/.config/autostart/xmodmap.desktop chmod +x ~/.config/autostart/xmodmap.desktop Remove hot-keys Super+Num 꼴의 단축키 사용을 위해서는 gssetting 을 이용해 수동으로 dash-to-dock 의 hot-keys 설정을 비활성화할 필요가 있습니다.\ngsettings set org.gnome.shell.extensions.dash-to-dock hot-keys false for i in $(seq 1 9); do gsettings set org.gnome.shell.keybindings switch-to-application-${i} \u0026#34;[]\u0026#34;; done Hibernate sudo apt install hibernate sudo vi /etc/default/grub GRUB_CMDLINE_LINUX_DEFAULT=\u0026quot;quiet splash resume=UUID=YOUR_VALUE\u0026quot; sudo update-grub 한글 입력 한국인 우분투 사용자의 최대 난제, 한글 입력 문제입니다. 보통 fcitx-hangul, uim-byeory, ibus-hangul 을 많이 사용하는데, 여기서는 현시점에서 가장 쓸만 하다고 판단되는 fcitx-gangul 과 uim-byeoru 설치법만을 소개하겠습니다.\nfcitx-hangul: 맞습니다. 악명이 자자한 가장 유명한 한글 입력기, fcitx 입니다. 예전보다 악명은 많이 줄었지만, 아직은 크롬에서 사용 시 심각한 수준으로 불안정한 모습을 보여 줍니다. 영 내키지는 않아도 fcitx 를 설치해 놓을 이유는 있습니다. snap으로 설치한 앱에서는 uim을 이용한 한글 입력이 불가능합니다. 꼭 snap으로 설치한 앱에서 한글을 적어야 한다면, fcitx도 따로 설치해 두시기를 권장 드립니다. 우선 fcitx-hangul 을 설치합니다.\nsudo apt install fcitx-hangul Setting \u0026gt; Region \u0026amp; Language \u0026gt; Manage installed Language \u0026gt; Keyboard input method system \u0026gt; fcitx 을 선택해 fcitx-hangul 을 적용한 이후 Region \u0026amp; Language 로 다시 돌아가, + 버튼을 눌러 Korean(Hangul) 을 찾아 적용합니다.\nKorean(Hangul) 을 적용했다면, 우측 상단에 보이는 EN 아이콘을 누른 뒤, setup 을 선택해 Hangul 과 Shift+Space 를 지우고 오른쪽 Alt를 눌러 Alt_R 을 인식시키면 이제 오른쪽 Alt키를 이용해 한글-영문을 전환할 수 있습니다.\nuim-byeoru: 그나마 안정적인 한글 입력기입니다. 한글이 아예 적히지 않는 경우가 적지 않지만, 깨져서 나온다거나 글자가 증발한다던가 하는 불안정한 동작은 확실히 fcitx 에 비해 덜합니다.\n Language Support \u0026gt; Keyboard input method system \u0026gt; uim 을 선택해 적용합니다. uim 에 진입하면 uim-pref-gtk UI 가 나옵니다. 여기서 Specify defuault IM 을 활성화한 뒤, Default Input Method 를 Byeoru 로 설정합니다. 좌측 메뉴에서 Byeoru key binding 1 을 선택해 [Byeoru] on 과 [Byeoru] off 에 Multi_key 를 인식시켜야 합니다. Grab... 을 눌렀을 때, Alt_key 가 잡힌다면 4번을 거쳐야 합니다. 정상적으로 Multi_key 가 인식된다면 5번으로 넘어 갑니다. Tweaks \u0026gt; Keyboard \u0026amp; Mouse \u0026gt; Compose Key 를 활성화해 Right Ctlr 를 선택해줍니다. 다시 3번으로 돌아가 오른쪽 Alt를 눌러 주면 Multi_key 로 인식이 될 것입니다. Multi_key 를 인식해 ON/OFF 에 할당했다면, Apply 를 눌러 적용합니다. 적용되었다면 로그아웃 및 로그인 하여 오른쪽 아래에 uim ui가 뜨는지 확인합니다.  Vim Vundle/airline/syntastics vim 을 위한 플러그인 관리 툴과 UI개선 플러그인, 문법 검증 플러그인입니다. 우선~/.vim/bundle/Vundle.vim폴더에 Vundle 을 클론 해줍니다.\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 이후 ~/.vimrc 에 아래 설정을 추가합니다. 이 설정은 미려한 Status-bar를 표시해주는 vim-airline 플러그인과 문법 오류를 표시해주는 vim-syntastic 플러그인, xclip 클립보드 연동 설정을 포함합니다.\necho \u0026#34;set nocompatible set number set clipboard=unnamedplus filetype off set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; Plugin \u0026#39;tpope/vim-fugitive\u0026#39; Plugin \u0026#39;git://git.wincent.com/command-t.git\u0026#39; Plugin \u0026#39;rstacruz/sparkup\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim/\u0026#39;} Plugin \u0026#39;vim-airline/vim-airline\u0026#39; Plugin \u0026#39;vim-airline/vim-airline-themes\u0026#39; let g:airline_powerline_fonts=1 Plugin \u0026#39;terryma/vim-expand-region\u0026#39; call vundle#end() filetype plugin indent on \u0026#34; \u0026gt; ~/.vimrc 설정을 추가했다면 vim 을 실행한 뒤, :PluginInstall 명령어를 입력해 플러그인 설치를 완료합니다.\nIdeaVim echo \u0026#39; set scrolloff=5 set incsearch set clipboard+=unnamed\u0026#39; \u0026gt; .ideavimrc Github git config --global user.name \u0026#34;example\u0026#34; git config --global user.email \u0026#34;example@gmail.com\u0026#34; git config --global color.ui true git config --global core.editor vi curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture)signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\u0026#34; | sudo tee /etc/apt/sources.list.d/github-cli.list \u0026gt; /dev/null sudo apt update sudo apt install gh https://github.com/settings/tokens\ngh auth SDKs Docker curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \\  \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs)stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update sudo apt install docker-ce docker-ce-cli sudo groupadd docker sudo usermod -aG docker $USER Docker compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo curl \\  -L https://raw.githubusercontent.com/docker/compose/1.29.2/contrib/completion/bash/docker-compose \\  -o /etc/bash_completion.d/docker-compose JDK sudo apt install default-jre openjdk-8-jdk openjdk-11-jdk SBT sudo apt install scala echo \u0026#34;deb https://dl.bintray.com/sbt/debian /\u0026#34; | sudo tee -a /etc/apt/sources.list.d/sbt.list sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823 sudo apt update \u0026amp;\u0026amp; sudo apt install sbt Android SDK 공식 홈페이지 - https://developer.android.com/studio#command-tools 에서 commandlinetools 를 다운로드 받은 뒤 설치합니다.\nmkdir .android unzip ~/Downloads/commandlinetools-linux-*.zip mv cmdline-tools .android/ .zshrc 아래에 다음 내용을 추가합니다.\necho \u0026#34;JAVA_HOME=\u0026#39;/usr/lib/jvm/java-8-openjdk-amd64\u0026#39; ANDROID_HOME=\u0026#39;$HOME/.android\u0026#39; export JAVA_HOME export ANDROID_HOME export PATH=\u0026#39;$PATH:$JAVA_HOME/bin:$ANDROID_HOME/cmdline-tools/bin:$ANDROID_HOME/platform-tools\u0026#39;\u0026#34; \u0026gt; .zshrc 추가된 내용을 source .zshrc 명령어로 업데이트한 뒤, sdkmanager 를 이용해 안드로이드 SDK 를 다운로드 받습니다.\nsdkmanager --sdk_root=$ANDROID_HOME \u0026#34;platform-tools\u0026#34; \u0026#34;platforms;android-29\u0026#34; \u0026#34;platforms;android-30\u0026#34; \u0026#34;build-tools;28.0.3\u0026#34; sdkmanager --sdk_root=$ANDROID_HOME --licenses Flutter mkdir .flutter cd .flutter git clone https://github.com/flutter/flutter.git -b stable --depth 1 .zshrc 아래에 다음 내용을 추가합니다.\nexport PATH=\u0026#34;$PATH:$HOME/.flutter/flutter/bin\u0026#34; 추가된 내용을 source .zshrc 명령어로 업데이트 한 뒤, Flutter 바이너리를 다운로드 받아 flutter doctor 를 실행해 정상 설치를 확인합니다.\nflutter precache flutter doctor --android-licenses flutter doctor Apps Chrome wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add - sudo sh -c \u0026#39;echo \u0026#34;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\u0026#34;\u0026gt;\u0026gt; /etc/apt/sources.list.d/google-chrome.list\u0026#39; sudo apt update \u0026amp;\u0026amp; sudo apt install google-chrome-stable 설치 후 Use System title bar and boarder 를 활성화 하고, ADBlock 을 설치 했다면 Allow Acceptable Ads 를 비활성화 합니다.\nsudo sed -i \u0026#39;s;/usr/bin/google-chrome-stable;/usr/bin/google-chrome-stable --enable-features=WebUIDarkMode --force-dark-mode;g\u0026#39; /usr/share/applications/google-chrome.desktop Jetbrains Tool box 공식 홈페이지 - https://www.jetbrains.com/ko-kr/toolbox-app/ 에서 툴박스 앱을 다운로드 받은 뒤 설치합니다.\ncd Downloads tar -xvf jetbrains-toolbox-*.tar.gz cd jetbrains-toolbox-* chmod 700 jetbrrains-toolbox ./jetbrains-toolbox Wine 6.0 sudo dpkg --add-architecture i386 sudo apt update sudo apt install software-properties-common sudo apt-add-repository \u0026#34;deb http://dl.winehq.org/wine-builds/ubuntu/ $(lsb_release -cs)main\u0026#34; sudo apt install --install-recommends winehq-stable TeXLive sudo apt install texlive-latex-recommended sudo apt install texlive-latex-recommended-doc Typora wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - sudo add-apt-repository \u0026#39;deb https://typora.io/linux ./\u0026#39; sudo apt update \u0026amp;\u0026amp; sudo apt install typora Discord wget -O ~/Downloads/discord.deb \u0026#34;https://discordapp.com/api/download?platform=linux\u0026amp;format=deb\u0026#34; sudo gdebi ~/Downloads/discord.deb 수동 다운로드를 상당히 자주 요구하기에, 스크립트로 만들어 놓으면 더 좋습니다.\nSpotify curl -sS https://download.spotify.com/debian/pubkey_0D811D58.gpg | sudo apt-key add - echo \u0026#34;deb http://repository.spotify.com stable non-free\u0026#34; | sudo tee /etc/apt/sources.list.d/spotify.list sudo apt update \u0026amp;\u0026amp; sudo apt install spotify-client WireShark sudo로 실행하지 않아도 패킷을 잡을 수 있도록 sudo권한을 부여합니다. 당연하겠지만 절대 서버/공용 환경에서 따라 하면 안 됩니다.\nsudo apt install wireshark sudo adduser $USER wireshark VLC sudo apt install vlc GIMP sudo add-apt-repository ppa:ubuntuhandbook1/gimp sudo apt update \u0026amp;\u0026amp; sudo apt install gimp Blender sudo add-apt-repository ppa:thomas-schiex/blender sudo apt update \u0026amp;\u0026amp; sudo apt install blender VirtualBox sudo apt install virtualbox HUGO sudo apt install hugo bottom curl -LO https://github.com/ClementTsang/bottom/releases/download/0.6.4/bottom_0.6.4_amd64.deb sudo dpkg -i bottom_0.6.4_amd64.deb Windows - UTC 타임존 Windows는 메인보드에 저장된 시간을 현지 시간으로, 리눅스는 UTC 시간으로 해석합니다. 이를 해결하기 위해서는, 윈도우가 메인보드에 저장된 시간을 UTC로 해석하도록 설정 할 필요가 있습니다. 먼저, 시작 메뉴에서 regedit 를 타이핑해 레지스트리 편집기를 실행한 뒤, 아래의 경로를 복사해 붙여 넣습니다.\n컴퓨터\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation 이후 우클릭으로 새 32bit DWORD 값을 만들고, 이름을 RealTimeIsUniversal 로 고칩니다. 만든 값을 더블클릭해 값을 1로 지정한 뒤 저장합니다.\n조금은 유용할 정보들 Inbound RST 패킷 차단 sudo iptables -I INPUT -p tcp --tcp-flags ALL RST -j DROP TTL 변경 echo \u0026#34;net.ipv4.ip_default_ttl=42\u0026#34; | sudo tee -a /etc/sysctl.conf 배경화면 큰 화면과 파랑 계열의 테마에 어울리는 단색기반 배경화면 과 작은 화면과 yaru 테마에 어울리는 그라이데션기반 배경화면 이 준비되어 있습니다. 진정한 돌고래러 라면 배경화면도 돌고래입니다.\nubuntu-orange: 우분투 스타일의 그라이데션을 배경으로 사용한 바탕화면입니다. 13.3인치 화면에 맞추어 제작되었으며, 16:9, 3200x1800 해상도가 준비돼 있습니다. 여기를 눌러 원본 크기로 다운로드 합니다.\nblue: 단색 파랑을 배경으로 사용한 바탕화면 입니다. 29인치 와 23인치 화면에 맞추어 제작되었으며, 21:9 16:9, 37:9(합쳐짐, 듀얼모니터 전용), 2560x1080, 1920x1080 해상도가 준비되어 있습니다. 이 링크(21:9) 와 이 링크(16:9), 이 링크(37:9) 를 눌러 원본 크기로 다운로드 합니다.\n듀얼모니터 GNOME Shell은 모니터별로 배경화면을 할당하는 기능을 제공하지 않습니다. 듀얼모니터에 서로 다른 배경화면을 설정하기 위해서는 가로로 합쳐진 이미지를 배경으로 설정한 뒤, 배경 표시 옵션을 spanned 로 설정해야 합니다.\ngsettings set org.gnome.desktop.background picture-options spanned ","permalink":"https://do1ph.in/posts/setup-ubuntu-20-04-lts/","summary":"우분투 20.04 장기 지원 버전(LTS) 이 릴리스 되었습니다. 매번 OS를 새로 설치할 때마다 삽질하지 않도록 우분투를 처음 설치했을 때 작업 환경을 세팅하는 과정을 글로 정리해 봤습니다. Pop! shell 및 ifcitx-hangul 설정과 uim-byeoru 설정, oh-my-zsh 설정과 vundle 등의 설정을 포함합니다.\n 개인적으로 사용하기 위해 정리한 성격이 강한 글입니다. 최소한 22.04 LTS가 나오기 전까지는 계속 업데이트 될 예정입니다. Ubuntu 20.04 LTS, 영문 기준으로 작성되었으며, RYZEN 1700 + GTX1080 + NVMe SSD  데스크톱과 DELL XPS 13 9350 랩톱 하드웨어에서 정상 작동을 확인했습니다.","title":"Ubuntu 20.04 LTS 설치 후 작업환경 구성하기"},{"content":"junghyun397 블로그, do1ph.in\n필요할 때 필요한 것들을 활용해 보다 가치 있는 문제를 해결하기를 원합니다. 주로 강화학습, 알고리즘, DevOps, 보안 등을 다룹니다. 사실 잡스러운 글이 더 많겠지만요.\n 모든 블로그의 글들은 Public Domain(CC0)으로 배포됩니다. 양심이 허락하는 한 어디든 마음대로 가져다 쓰셔도 좋습니다. 정적 페이지 생성기 Hugo를 이용해 생성되었으며, Github-pages를 이용해 호스팅 됩니다. 블로그 테마 및 마크다운으로 작성된 원본 포스트는 blog 저장소를, 마크업으로 변환돼 현재 호스팅 되고 있는 블로그는 junghyun397.github.io 저장소에서 확인하실 수 있습니다. 시스템/브라우저 설정에 따라 자동으로 다크 테마를 표시합니다. 웹사이트 구조상 테마 토글 기능은 지원하지 않습니다. 사이트맵은 https://do1ph.in/sitemap.xml, RSS 피드는 https://do1ph.in/index.xml 에 있습니다.  모호하거나 틀린 서술, 더 궁금한 내용이 있다면, junghyun397@gmail.com이나 아래 적혀있는 연락처로 연락 부탁드립니다. :)\n Github • LinkedIn • FaceBook • Discord • Steam\n","permalink":"https://do1ph.in/about/","summary":"junghyun397 블로그, do1ph.in\n필요할 때 필요한 것들을 활용해 보다 가치 있는 문제를 해결하기를 원합니다. 주로 강화학습, 알고리즘, DevOps, 보안 등을 다룹니다. 사실 잡스러운 글이 더 많겠지만요.\n 모든 블로그의 글들은 Public Domain(CC0)으로 배포됩니다. 양심이 허락하는 한 어디든 마음대로 가져다 쓰셔도 좋습니다. 정적 페이지 생성기 Hugo를 이용해 생성되었으며, Github-pages를 이용해 호스팅 됩니다. 블로그 테마 및 마크다운으로 작성된 원본 포스트는 blog 저장소를, 마크업으로 변환돼 현재 호스팅 되고 있는 블로그는 junghyun397.github.io 저장소에서 확인하실 수 있습니다.","title":"About"}]